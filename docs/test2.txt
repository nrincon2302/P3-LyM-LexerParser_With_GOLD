(defvar myVar 10)
(= myVar 20)
(move 5)
(skip 3)
(turn :left)
(face :north)
(put :balloons 3)
(pick :chips 2)
(move-dir 4 :front)
(run-dirs :front :left :front)
(move-face 8 :west)
(null)
(if (facing? north) (= myVar 30) (= myVar 40))
(loop (not (blocked?)) (move 1))
(repeat 5 (move 2))
(defun myFunction (param1 param2) (move 3))
(myFunction 10 20)
(if (can-put? chips 2) (put :chips 2) (null))
(if (can-pick? balloons 3) (pick :balloons 3) (null))
(if (can-move? :north) (move 2) (null))
(if (isZero? myVar) (move 5) (turn :right))
(if (not (blocked?)) (move 1) (null))
(loop (not (isZero? myVar)) (= myVar myVar))
(repeat 3 (face :south))
(defun myRepeatFunction (n) (repeat n (move 1)))
(myRepeatFunction 4)
(if (facing? east) (turn :around) (null))
(if (can-move? :north) (face :north) (null))
(if (not (can-pick? balloons 2)) (move 3) (pick :balloons 2))
((defun myLoopFunction (n) (loop (not (isZero? n)) (move 1))))

((if (facing? north)
    (loop (not (blocked?))
          (if (can-pick? balloons 2)
              (pick :balloons 2)
              (null)))
    (face :south)))


(defun myNewFunction (n)
    (repeat n
        (if (can-put? chips 1)
            (put :chips 1)
            (null))))
(myNewFunction 3)

(if (not (blocked?))
    (loop (not (isZero? myVar))
          (if (can-move? :west)
              (move 1)
              (turn :right)))
    (null))



(loop (not (isZero? myVar))
    (if (can-move? :east)
        (move 1)
        (turn :left)))

(defun moveAndPut (n)
    (move n)
    (put :balloons n))

(defun repeatActions (m)
    (repeat m
        (moveAndPut 2)))

(repeatActions 3)

(((((defun factorial (n)
    (if (isZero? n)
        (defvar rta 1)
        (factorial n)))

(factorial 5)))))


(loop (not (blocked?))
    (if (can-move? :south)
        (move 1)
        (if (can-pick? chips 2)
            (pick :chips 2)
            (turn :right))))

(
(
(defun moveAndPutv2 (steps)
    (loop (not (isZero? steps))
        (if (can-move? :south)
            (move 1)
            (if (can-put? balloons 1)
                (put :balloons 1)
                ((turn :left)
        		 (= steps balloonshere))))
        ))
        
(defun moveAndPickv2 (steps)
    (loop (not (isZero? steps))
        (if (facing? north)
            (move 1)
            (if (can-pick? chips 1)
                (pick :chips 1)
                ((turn :right)
        		 (= steps chipshere))))
        ))

(if (facing? north)
    (loop (not (blocked?))
        (if (can-move? :west)
            (moveAndPickv2 2)
            (if (can-pick? balloons 1)
                (pick :balloons 1)
                (turn :right))))
    (loop (not (blocked?))
        (if (can-move? :east)
            (moveAndPutv2 3)
            (if (can-put? chips 1)
                (put :chips 1)
                (turn :left)))))

)
)

